{
  "version": 3,
  "sources": ["../src/main.ts"],
  "sourcesContent": ["/*\n * Created with @iobroker/create-adapter v2.1.1\n */\n\nimport * as utils from '@iobroker/adapter-core';\nimport { IFollower } from './interfaces/follower.interface';\nimport { IStream } from './interfaces/stream.interface';\nimport { TwitchApi } from './lib/twitch-api';\n\nclass Twitch extends utils.Adapter {\n    private twitchApi: TwitchApi | undefined;\n    private updateOnlineStateInterval = 0;\n    public constructor(options: Partial<utils.AdapterOptions> = {}) {\n        super({\n            ...options,\n            name: 'twitch',\n        });\n        this.on('ready', this.onReady.bind(this));\n        this.on('stateChange', this.onStateChange.bind(this));\n        // this.on('objectChange', this.onObjectChange.bind(this));\n        // this.on('message', this.onMessage.bind(this));\n        this.on('unload', this.onUnload.bind(this));\n    }\n\n    /**\n     * Is called when databases are connected and adapter received configuration.\n     */\n    private async onReady(): Promise<void> {\n        if (!this.config.authToken) {\n            this.log.error('Auth token is empty - please check instance configuration');\n            return;\n        }\n\n        if (!this.config.username) {\n            this.log.error('Username is empty - please check instance configuration');\n            return;\n        }\n\n        this.log.info('Auth token: ' + this.config.authToken);\n        this.log.info('Twitch Username: ' + this.config.username);\n\n        this.twitchApi = new TwitchApi(this.config.authToken, this.config.username, this.log);\n\n        try {\n            await this.twitchApi.initialize();\n            await this.setStateAsync('info.connection', { val: true, ack: true });\n        } catch (err: any) {\n            await this.setStateAsync('info.connection', { val: false, ack: true });\n        }\n\n        this.updateFollowersInStore();\n\n        // this.updateOnlineStateInterval = this.setInterval(() => {\n        //     await this.twitchApi.getOnlineStreams();\n        // }, 60000);\n    }\n\n    private async updateFollowersInStore(): Promise<void> {\n        const followers = await this.twitchApi?.getFollowers();\n        if (!followers) {\n            return;\n        }\n\n        if (followers.length > 0) {\n            await this.createFolder('channels', 'Followed Twitch Channels');\n        }\n\n        const liveStreams = await this.twitchApi?.getLiveStreamsIFollow();\n\n        for (const follower of followers) {\n            const followerId = follower.to_name;\n            const streamStatus = liveStreams?.find((stream) => {\n                return stream.user_name === followerId;\n            });\n\n            this.log.error('Stream status ' + streamStatus?.type);\n\n            const followerChannelId = `channels.${followerId}`;\n            await this.createFolder(followerChannelId, 'Followed Twitch Channel');\n            await this.createOrUpdateState(followerChannelId, follower, streamStatus);\n        }\n    }\n\n    private async createFolder(id: string, name: string): Promise<any> {\n        await this.setObjectNotExistsAsync(id, {\n            type: 'channel',\n            common: {\n                name: name,\n            },\n            native: {},\n        });\n    }\n\n    private async createOrUpdateState(\n        followerId: string,\n        follower: IFollower,\n        stream: IStream | undefined,\n    ): Promise<any> {\n        const onlineStateId = `${followerId}.online`;\n        await this.setObjectNotExistsAsync(onlineStateId, {\n            type: 'state',\n            common: {\n                name: 'Online status',\n                type: 'boolean',\n                role: 'indicator',\n                read: true,\n                write: false,\n            },\n            native: {},\n        });\n\n        await this.setStateAsync(onlineStateId, { val: stream?.type === 'live' ? true : false, ack: true });\n    }\n\n    /**\n     * Is called when adapter shuts down - callback has to be called under any circumstances!\n     */\n    private onUnload(callback: () => void): void {\n        try {\n            this.setState('info.connection', { val: false, ack: true });\n            callback();\n        } catch (e) {\n            callback();\n        }\n    }\n\n    /**\n     * Is called if a subscribed state changes\n     */\n    private onStateChange(id: string, state: ioBroker.State | null | undefined): void {\n        if (state) {\n            // The state was changed\n            this.log.info(`state ${id} changed: ${state.val} (ack = ${state.ack})`);\n        } else {\n            // The state was deleted\n            this.log.info(`state ${id} deleted`);\n        }\n    }\n}\n\nif (require.main !== module) {\n    // Export the constructor in compact mode\n    module.exports = (options: Partial<utils.AdapterOptions> | undefined) => new Twitch(options);\n} else {\n    // otherwise start the instance directly\n    (() => new Twitch())();\n}\n"],
  "mappings": "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",
  "names": []
}
